{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/interfaces/IRewardCampaign.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.18;\r\n\r\nimport {PMLibrary} from \"../library/PMLibrary.sol\";\r\n\r\ninterface IRewardCampaign {\r\n    function investTokens(address onBehalf, uint256 amount, PMLibrary.InvestmentType _type) external;\r\n    function claimTokensAndReward(uint256 _tokenId) external;  \r\n    function getTokenData(uint256 _tokenId) external view returns(PMLibrary.TokenData memory);\r\n    function getProjectInfo() external view returns ( PMLibrary.PoolFullInfo memory poolFullInfo);\r\n}"
    },
    "contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.18;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n"
    },
    "contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.18;\r\n\r\nimport {IUniswapV2Router01} from './IUniswapV2Router01.sol';\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n"
    },
    "contracts/library/PMLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.18;\r\n\r\nlibrary PMLibrary {\r\n    \r\n    enum ProfileType {\r\n        NONE,\r\n        TEAM,\r\n        USER\r\n    }\r\n\r\n    enum InvestmentType {\r\n        ONE_MONTH,\r\n        THREE_MONTH,\r\n        SIX_MONTH,\r\n        NINE_MONTH,\r\n        TWELVE_MONTH\r\n    }\r\n\r\n    enum MembershipCategories {\r\n        MEMBER,\r\n        TEAM\r\n    }\r\n\r\n    enum ClaimCategories{\r\n        REWARD_0pc,\r\n        REWARD_30pc,\r\n        REWARD_50pc,\r\n        REWARD_100pc\r\n    }\r\n\r\n    enum CampaignCategories {\r\n        SILVER,\r\n        GOLD,\r\n        DIAMOND\r\n    }\r\n\r\n    enum FeesType {\r\n        USD,\r\n        BNB\r\n    }\r\n\r\n\r\n    struct PoolInfo {\r\n        uint256 poolId;\r\n        address poolAddress;\r\n        uint256 remainingPool;\r\n        uint256 totalTokensInvested;\r\n        uint256 totalParicipants;\r\n        uint256 tokenCounter;\r\n        address poolOwner;\r\n    }\r\n\r\n    struct ProjectInfo {\r\n        CampaignCategories category;\r\n        string projectName;\r\n        string projectSymbol;\r\n        address tokenAddress;\r\n        uint8 tokenDecimals;\r\n        string tokenSymbol;\r\n        ProfileType profileType;\r\n        uint256 profileId;\r\n    }\r\n\r\n    struct RewardPoolInfo {\r\n        uint256 startedAt;\r\n        uint256 poolAmount;\r\n    }\r\n\r\n    struct NFTData {\r\n        string image_1_months;\r\n        string image_3_months;\r\n        string image_6_months;\r\n        string image_9_months;\r\n        string image_12_months;\r\n        uint8 APY_1_months;\r\n        uint8 APY_3_months;\r\n        uint8 APY_6_months;\r\n        uint8 APY_9_months;\r\n        uint8 APY_12_months;\r\n    }\r\n\r\n    struct TokenData {\r\n        address poolAddress;\r\n        uint256 poolId;\r\n        uint256 tokenInvested;\r\n        address tokenAddress;\r\n        address owner;\r\n        address creator;\r\n        uint256 tokenId;\r\n        string tokenUri;\r\n        InvestmentType investmentType;\r\n        uint256 investmentTime;\r\n        uint256 unlockTime;\r\n        uint256 expectedReward;\r\n        bool isUnskated;\r\n        uint256 redeemedReward;\r\n        uint8 pcReceived;\r\n    }\r\n\r\n    struct PoolFullInfo {\r\n        PoolInfo poolInfo;\r\n        ProjectInfo projectInfo;\r\n        RewardPoolInfo rewardPoolInfo;\r\n        NFTData nftData;\r\n    }\r\n}\r\n"
    },
    "contracts/Planetmoon/CampaignFeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.18;\r\n\r\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport {PMLibrary} from \"../library/PMLibrary.sol\";\r\nimport {IUniswapV2Router02} from \"../interfaces/IUniswapV2Router02.sol\";\r\nimport {PriceFeed} from \"./PriceFeed.sol\";\r\nimport {SwapETHForTokens} from \"./SwapETHForTokens.sol\";\r\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\nimport {IUniswapV2Router02} from \"../interfaces/IUniswapV2Router02.sol\";\r\n\r\n// import \"hardhat/console.sol\";\r\n\r\ncontract CampaignFeeManager is Ownable, PriceFeed, SwapETHForTokens {\r\n    mapping(PMLibrary.CampaignCategories category => uint256 fee)\r\n        private s_campaingFee;\r\n    mapping(PMLibrary.ClaimCategories category => uint256 fee)\r\n        private s_claimingFee;\r\n\r\n    FeeDistributionShares private s_feeDistributionShares;\r\n    FeeDistributionWallets private s_feeDistributionWallets;\r\n\r\n    event Received(address, uint);\r\n\r\n    struct FeeDistributionShares {\r\n        uint8 buyBackAndburn;\r\n        uint8 rewardPool;\r\n        uint8 corporate;\r\n    }\r\n\r\n    struct FeeDistributionWallets {\r\n        address payable rewardPool;\r\n        address payable corporate;\r\n        address buyBackAndburnToken;\r\n        address buyBackReceiver;\r\n    }\r\n\r\n    constructor(\r\n        uint256 silver,\r\n        uint256 gold,\r\n        uint256 diamond,\r\n        uint256 reward_0pc,\r\n        uint256 reward_30pc,\r\n        uint256 reward_50pc,\r\n        uint256 reward_100pc\r\n    ) {\r\n        s_campaingFee[PMLibrary.CampaignCategories.SILVER] = silver;\r\n        s_campaingFee[PMLibrary.CampaignCategories.GOLD] = gold;\r\n        s_campaingFee[PMLibrary.CampaignCategories.DIAMOND] = diamond;\r\n\r\n        s_claimingFee[\r\n            PMLibrary.ClaimCategories.REWARD_0pc\r\n        ] = reward_0pc;\r\n        s_claimingFee[\r\n            PMLibrary.ClaimCategories.REWARD_30pc\r\n        ] = reward_30pc;\r\n        s_claimingFee[\r\n            PMLibrary.ClaimCategories.REWARD_50pc\r\n        ] = reward_50pc;\r\n        s_claimingFee[\r\n            PMLibrary.ClaimCategories.REWARD_100pc\r\n        ] = reward_100pc;\r\n    }\r\n\r\n    function getCampaignFee(\r\n        PMLibrary.CampaignCategories category\r\n    ) public view returns (uint256) {\r\n        uint256 priceOfOneUSD = uint256(getLatestPriceOfOneUSD());\r\n        return s_campaingFee[category] * priceOfOneUSD;\r\n    }\r\n\r\n    function getAllCampaignFees(\r\n        PMLibrary.FeesType feeType\r\n    ) public view returns (uint256 silver, uint256 gold, uint256 diamond) {\r\n        silver = s_campaingFee[PMLibrary.CampaignCategories.SILVER];\r\n        gold = s_campaingFee[PMLibrary.CampaignCategories.GOLD];\r\n        diamond = s_campaingFee[PMLibrary.CampaignCategories.DIAMOND];\r\n\r\n        if (feeType == PMLibrary.FeesType.BNB) {\r\n            uint256 priceOfOneUSD = uint256(getLatestPriceOfOneUSD());\r\n            silver = silver * priceOfOneUSD;\r\n            gold = gold * priceOfOneUSD;\r\n            diamond = diamond * priceOfOneUSD;\r\n        }\r\n    }\r\n\r\n    function getDistributionShares()\r\n        public\r\n        view\r\n        returns (uint8 buyBackAndburn, uint8 rewardPool, uint8 corporate)\r\n    {\r\n        buyBackAndburn = s_feeDistributionShares.buyBackAndburn;\r\n        rewardPool = s_feeDistributionShares.rewardPool;\r\n        corporate = s_feeDistributionShares.corporate;\r\n    }\r\n\r\n    function getDistributionWallets()\r\n        public\r\n        view\r\n        returns (\r\n            address rewardPool,\r\n            address corporate,\r\n            address buyBackAndburnToken,\r\n            address buyBackReceiver\r\n        )\r\n    {\r\n        rewardPool = s_feeDistributionWallets.rewardPool;\r\n        corporate = s_feeDistributionWallets.corporate;\r\n        buyBackAndburnToken = s_feeDistributionWallets.buyBackAndburnToken;\r\n        buyBackReceiver = s_feeDistributionWallets.buyBackReceiver;\r\n    }\r\n\r\n    function setCampaignFees(\r\n        uint256 silver,\r\n        uint256 gold,\r\n        uint256 diamond\r\n    ) public onlyOwner {\r\n        s_campaingFee[PMLibrary.CampaignCategories.SILVER] = silver;\r\n        s_campaingFee[PMLibrary.CampaignCategories.GOLD] = gold;\r\n        s_campaingFee[PMLibrary.CampaignCategories.DIAMOND] = diamond;\r\n    }\r\n\r\n    function getClaimFee(\r\n        PMLibrary.ClaimCategories category\r\n    ) public view returns (uint256) {\r\n        uint256 priceOfOneUSD = uint256(getLatestPriceOfOneUSD());\r\n        return s_claimingFee[category] * priceOfOneUSD;\r\n    }\r\n\r\n    function getAllClaimFees(\r\n        PMLibrary.FeesType feeType\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            uint256 reward_0pc,\r\n            uint256 reward_30pc,\r\n            uint256 reward_50pc,\r\n            uint256 reward_100pc\r\n        )\r\n    {\r\n        reward_0pc = s_claimingFee[\r\n            PMLibrary.ClaimCategories.REWARD_0pc\r\n        ];\r\n        reward_30pc = s_claimingFee[\r\n            PMLibrary.ClaimCategories.REWARD_30pc\r\n        ];\r\n        reward_50pc = s_claimingFee[\r\n            PMLibrary.ClaimCategories.REWARD_50pc\r\n        ];\r\n        reward_100pc = s_claimingFee[\r\n            PMLibrary.ClaimCategories.REWARD_100pc\r\n        ];\r\n\r\n        if (feeType == PMLibrary.FeesType.BNB) {\r\n            uint256 priceOfOneUSD = uint256(getLatestPriceOfOneUSD());\r\n            reward_0pc = reward_0pc * priceOfOneUSD;\r\n            reward_30pc = reward_30pc * priceOfOneUSD;\r\n            reward_50pc = reward_50pc * priceOfOneUSD;\r\n            reward_100pc = reward_100pc * priceOfOneUSD;\r\n        }\r\n    }\r\n\r\n    function setClaimFees(\r\n        uint256 reward_0pc,\r\n        uint256 reward_30pc,\r\n        uint256 reward_50pc,\r\n        uint256 reward_100pc\r\n    ) public onlyOwner {\r\n        s_claimingFee[\r\n            PMLibrary.ClaimCategories.REWARD_0pc\r\n        ] = reward_0pc;\r\n        s_claimingFee[\r\n            PMLibrary.ClaimCategories.REWARD_30pc\r\n        ] = reward_30pc;\r\n        s_claimingFee[\r\n            PMLibrary.ClaimCategories.REWARD_50pc\r\n        ] = reward_50pc;\r\n        s_claimingFee[\r\n            PMLibrary.ClaimCategories.REWARD_100pc\r\n        ] = reward_100pc;\r\n    }\r\n\r\n    function setFeeDistributionShares(\r\n        uint8 buyBackAndburn,\r\n        uint8 rewardPool,\r\n        uint8 corporate\r\n    ) public onlyOwner {\r\n        require(\r\n            corporate > 0 &&\r\n                rewardPool > 0 &&\r\n                buyBackAndburn + rewardPool + corporate == 100,\r\n            \"Distribution fees are not adding up to 100pc\"\r\n        );\r\n\r\n        s_feeDistributionShares.buyBackAndburn = buyBackAndburn;\r\n        s_feeDistributionShares.rewardPool = rewardPool;\r\n        s_feeDistributionShares.corporate = corporate;\r\n    }\r\n\r\n    function setFeeDistributionWallets(\r\n        address rewardPool,\r\n        address corporate,\r\n        address buyBackAndburnToken,\r\n        address buyBackReceiver\r\n    ) public onlyOwner {\r\n        require(\r\n            rewardPool != address(0) &&\r\n                corporate != address(0) &&\r\n                buyBackAndburnToken != address(0) &&\r\n                buyBackReceiver != address(0),\r\n            \"Distribution wallets are not being set properly\"\r\n        );\r\n\r\n        s_feeDistributionWallets.rewardPool = payable(rewardPool);\r\n        s_feeDistributionWallets.corporate = payable(corporate);\r\n        s_feeDistributionWallets.buyBackAndburnToken = buyBackAndburnToken;\r\n        s_feeDistributionWallets.buyBackReceiver = buyBackReceiver;\r\n    }\r\n\r\n    function SplitFunds() public onlyOwner {\r\n        FeeDistributionWallets memory wallets = s_feeDistributionWallets;\r\n        FeeDistributionShares memory fees = s_feeDistributionShares;\r\n\r\n        require(\r\n            wallets.rewardPool != address(0) &&\r\n                wallets.corporate != address(0) &&\r\n                wallets.buyBackAndburnToken != address(0) &&\r\n                wallets.buyBackReceiver != address(0),\r\n            \"Distribution wallets are not being set properly\"\r\n        );\r\n\r\n        require(\r\n            fees.corporate > 0 &&\r\n                fees.rewardPool > 0 &&\r\n                fees.buyBackAndburn + fees.rewardPool + fees.corporate == 100,\r\n            \"Distribution fees are not being set properly\"\r\n        );\r\n\r\n        uint256 totalBalance = address(this).balance;\r\n        require(totalBalance > 0, \"No balance avaialble for split\");\r\n\r\n        uint256 corporateShare = (totalBalance * fees.corporate) / 100;\r\n        uint256 rewardPoolShare = (totalBalance * fees.rewardPool) / 100;\r\n        uint256 buyBackAndBurnShare = totalBalance -\r\n            corporateShare -\r\n            rewardPoolShare;\r\n\r\n        wallets.corporate.transfer(corporateShare);\r\n        wallets.rewardPool.transfer(rewardPoolShare);\r\n        if (buyBackAndBurnShare > 0) {\r\n            swapETHForTokens(\r\n                wallets.buyBackAndburnToken,\r\n                wallets.buyBackReceiver,\r\n                buyBackAndBurnShare\r\n            );\r\n        }\r\n    }\r\n\r\n    function emergencyWithdraw() public onlyOwner {\r\n        uint256 totalBalance = address(this).balance;\r\n        require(totalBalance > 0, \"No balance avaialble for withdraw\");\r\n        payable(owner()).transfer(totalBalance);\r\n    }\r\n\r\n    function updateRouter(\r\n        IUniswapV2Router02 _uniswapV2Router\r\n    ) public onlyOwner {\r\n        uniswapV2Router = _uniswapV2Router;\r\n    }\r\n\r\n    function updatePriceFeed(\r\n        AggregatorV3Interface _priceFeed\r\n    ) public onlyOwner {\r\n        priceFeed = _priceFeed;\r\n    }\r\n\r\n    receive() external payable {\r\n        emit Received(msg.sender, msg.value);\r\n    }\r\n}\r\n"
    },
    "contracts/Planetmoon/MembershipFeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.18;\r\n\r\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport {PMLibrary} from \"../library/PMLibrary.sol\";\r\nimport {IUniswapV2Router02} from \"../interfaces/IUniswapV2Router02.sol\";\r\nimport {PriceFeed} from \"./PriceFeed.sol\";\r\nimport {SwapETHForTokens} from \"./SwapETHForTokens.sol\";\r\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\nimport {IUniswapV2Router02} from \"../interfaces/IUniswapV2Router02.sol\";\r\n\r\n// import \"hardhat/console.sol\";\r\n\r\ncontract MembershipFeeManager is Ownable, PriceFeed, SwapETHForTokens {\r\n    mapping(PMLibrary.MembershipCategories category => uint256 fee) private s_membershipFee;\r\n    FeeDistributionShares private s_feeDistributionShares;\r\n    FeeDistributionWallets private s_feeDistributionWallets;\r\n\r\n    event Received(address, uint);\r\n\r\n    struct FeeDistributionShares {\r\n        uint8 buyBackAndburn;\r\n        uint8 rewardPool;\r\n        uint8 corporate;\r\n    }\r\n\r\n    struct FeeDistributionWallets {\r\n        address payable rewardPool;\r\n        address payable corporate;\r\n        address buyBackAndburnToken;\r\n        address buyBackReceiver;\r\n    }\r\n\r\n    constructor(uint256 member, uint256 team) {\r\n        s_membershipFee[PMLibrary.MembershipCategories.MEMBER] = member;\r\n        s_membershipFee[PMLibrary.MembershipCategories.TEAM] = team;\r\n    }\r\n\r\n    function getMembershipFee(\r\n        PMLibrary.MembershipCategories category\r\n    ) public view returns (uint256) {\r\n        uint256 priceOfOneUSD = uint256(getLatestPriceOfOneUSD());\r\n        return s_membershipFee[category] * priceOfOneUSD;\r\n    }\r\n\r\n    function getAllFees(\r\n        PMLibrary.FeesType feeType\r\n    ) public view returns (uint256 member, uint256 team) {\r\n        member = s_membershipFee[PMLibrary.MembershipCategories.MEMBER];\r\n        team = s_membershipFee[PMLibrary.MembershipCategories.TEAM];\r\n\r\n        if (feeType == PMLibrary.FeesType.BNB) {\r\n            uint256 priceOfOneUSD = uint256(getLatestPriceOfOneUSD());\r\n            member = member * priceOfOneUSD;\r\n            team = team * priceOfOneUSD;\r\n        }\r\n    }\r\n\r\n    function getDistributionShares()\r\n        public\r\n        view\r\n        returns (uint8 buyBackAndburn, uint8 rewardPool, uint8 corporate)\r\n    {\r\n        buyBackAndburn = s_feeDistributionShares.buyBackAndburn;\r\n        rewardPool = s_feeDistributionShares.rewardPool;\r\n        corporate = s_feeDistributionShares.corporate;\r\n    }\r\n\r\n    function getDistributionWallets()\r\n        public\r\n        view\r\n        returns (\r\n            address rewardPool,\r\n            address corporate,\r\n            address buyBackAndburnToken,\r\n            address buyBackReceiver\r\n        )\r\n    {\r\n        rewardPool = s_feeDistributionWallets.rewardPool;\r\n        corporate = s_feeDistributionWallets.corporate;\r\n        buyBackAndburnToken = s_feeDistributionWallets.buyBackAndburnToken;\r\n        buyBackReceiver = s_feeDistributionWallets.buyBackReceiver;\r\n    }\r\n\r\n    function setMembershipFee(uint256 member, uint256 team) public onlyOwner {\r\n        s_membershipFee[PMLibrary.MembershipCategories.MEMBER] = member;\r\n        s_membershipFee[PMLibrary.MembershipCategories.TEAM] = team;\r\n    }\r\n\r\n    function setFeeDistributionShares(\r\n        uint8 buyBackAndburn,\r\n        uint8 rewardPool,\r\n        uint8 corporate\r\n    ) public onlyOwner {\r\n        require(\r\n            corporate > 0 &&\r\n                rewardPool > 0 &&\r\n                buyBackAndburn + rewardPool + corporate == 100,\r\n            \"Distribution fees are not adding up to 100pc\"\r\n        );\r\n\r\n        s_feeDistributionShares.buyBackAndburn = buyBackAndburn;\r\n        s_feeDistributionShares.rewardPool = rewardPool;\r\n        s_feeDistributionShares.corporate = corporate;\r\n    }\r\n\r\n    function setFeeDistributionWallets(\r\n        address rewardPool,\r\n        address corporate,\r\n        address buyBackAndburnToken,\r\n        address buyBackReceiver\r\n    ) public onlyOwner {\r\n        require(\r\n            rewardPool != address(0) &&\r\n                corporate != address(0) &&\r\n                buyBackAndburnToken != address(0) &&\r\n                buyBackReceiver != address(0),\r\n            \"Distribution wallets are not being set properly\"\r\n        );\r\n\r\n        s_feeDistributionWallets.rewardPool = payable(rewardPool);\r\n        s_feeDistributionWallets.corporate = payable(corporate);\r\n        s_feeDistributionWallets.buyBackAndburnToken = buyBackAndburnToken;\r\n        s_feeDistributionWallets.buyBackReceiver = buyBackReceiver;\r\n    }\r\n\r\n    function splitFunds() public onlyOwner {\r\n        FeeDistributionWallets memory wallets = s_feeDistributionWallets;\r\n        FeeDistributionShares memory fees = s_feeDistributionShares;\r\n\r\n        require(\r\n            wallets.rewardPool != address(0) &&\r\n                wallets.corporate != address(0) &&\r\n                wallets.buyBackAndburnToken != address(0) &&\r\n                wallets.buyBackReceiver != address(0),\r\n            \"Distribution wallets are not being set properly\"\r\n        );\r\n\r\n        require(\r\n            fees.corporate > 0 &&\r\n                fees.rewardPool > 0 &&\r\n                fees.buyBackAndburn + fees.rewardPool + fees.corporate == 100,\r\n            \"Distribution fees are not being set properly\"\r\n        );\r\n\r\n        uint256 totalBalance = address(this).balance;\r\n        require(totalBalance > 0, \"No balance avaialble for split\");\r\n\r\n        uint256 corporateShare = (totalBalance * fees.corporate) / 100;\r\n        uint256 rewardPoolShare = (totalBalance * fees.rewardPool) / 100;\r\n        uint256 buyBackAndBurnShare = totalBalance -\r\n            corporateShare -\r\n            rewardPoolShare;\r\n\r\n        wallets.corporate.transfer(corporateShare);\r\n        wallets.rewardPool.transfer(rewardPoolShare);\r\n        if (buyBackAndBurnShare > 0) {\r\n            swapETHForTokens(\r\n                wallets.buyBackAndburnToken,\r\n                wallets.buyBackReceiver,\r\n                buyBackAndBurnShare\r\n            );\r\n        }\r\n    }\r\n\r\n    function emergencyWithdraw() public onlyOwner {\r\n        uint256 totalBalance = address(this).balance;\r\n        require(totalBalance > 0, \"No balance avaialble for withdraw\");\r\n        payable(owner()).transfer(totalBalance);\r\n    }\r\n\r\n    function updateRouter(\r\n        IUniswapV2Router02 _uniswapV2Router\r\n    ) public onlyOwner {\r\n        uniswapV2Router = _uniswapV2Router;\r\n    }\r\n\r\n    function updatePriceFeed(\r\n        AggregatorV3Interface _priceFeed\r\n    ) public onlyOwner {\r\n        priceFeed = _priceFeed;\r\n    }\r\n\r\n    receive() external payable {\r\n        emit Received(msg.sender, msg.value);\r\n    }\r\n}\r\n"
    },
    "contracts/Planetmoon/PMRewardDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.18;\r\n\r\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport {PMLibrary} from \"../library/PMLibrary.sol\";\r\nimport {IUniswapV2Router02} from \"../interfaces/IUniswapV2Router02.sol\";\r\nimport {IRewardCampaign} from \"../interfaces/IRewardCampaign.sol\";\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {PriceFeed} from \"./PriceFeed.sol\";\r\nimport {SwapETHForTokens} from \"./SwapETHForTokens.sol\";\r\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\nimport {IUniswapV2Router02} from \"../interfaces/IUniswapV2Router02.sol\";\r\n\r\n// import \"hardhat/console.sol\";\r\n\r\ncontract PMRewardDistributor is Ownable, PriceFeed, SwapETHForTokens {\r\n\r\n    error PMRewardDistributor__NOT_ENOUGH_BALANCE();\r\n    error PMRewardDistributor__CONTRACT_IS_PAUSED();\r\n    error PMRewardDistributor__Not_Authorized();\r\n\r\n    address private s_giveAwayManager;\r\n    bool private s_isPaused = true;\r\n    uint256 private s_totalRewardDistributed;\r\n\r\n    event Received(address, uint);\r\n    event RewardApplied(address, address, uint256, uint8);\r\n\r\n    constructor(address _giveAwayManager) {\r\n        s_giveAwayManager = _giveAwayManager;\r\n    }\r\n\r\n    modifier onlyGiveAwayManager() {\r\n        if(msg.sender != s_giveAwayManager){\r\n            revert PMRewardDistributor__Not_Authorized();\r\n        }\r\n        _;\r\n    }\r\n\r\n    function getGiveAwayManager() external view returns (address) {\r\n        return s_giveAwayManager;\r\n    }\r\n\r\n    function getTotalRewardDistributed() external view returns (uint256) {\r\n        return s_totalRewardDistributed;\r\n    }\r\n\r\n    function isPaused() external view returns (bool) {\r\n        return s_isPaused;\r\n    }\r\n\r\n    function distributeReward(\r\n        address winner,\r\n        uint8 prizeUSD\r\n    ) external onlyGiveAwayManager {\r\n        if (s_isPaused) {\r\n            revert PMRewardDistributor__CONTRACT_IS_PAUSED();\r\n        }\r\n\r\n        uint256 priceOfOneUSD = uint256(getLatestPriceOfOneUSD());\r\n\r\n        uint256 prizeBNB = priceOfOneUSD * prizeUSD;\r\n        s_totalRewardDistributed += prizeBNB;\r\n\r\n        uint256 totalBalance = address(this).balance;\r\n\r\n        if (totalBalance < prizeBNB) {\r\n            revert PMRewardDistributor__NOT_ENOUGH_BALANCE();\r\n        }\r\n        payable(winner).transfer(prizeBNB);\r\n    }\r\n\r\n    function applyRewardToACampaing(\r\n        address campaign,\r\n        address user,\r\n        uint8 amountUSD,\r\n        PMLibrary.InvestmentType _type\r\n    ) external onlyGiveAwayManager {\r\n        if (s_isPaused) {\r\n            revert PMRewardDistributor__CONTRACT_IS_PAUSED();\r\n        }\r\n\r\n        uint256 priceOfOneUSD = uint256(getLatestPriceOfOneUSD());\r\n\r\n        uint256 amount = priceOfOneUSD * amountUSD;\r\n        s_totalRewardDistributed += amount;\r\n\r\n        uint256 totalBalance = address(this).balance;\r\n\r\n        if (totalBalance < amount) {\r\n            revert PMRewardDistributor__NOT_ENOUGH_BALANCE();\r\n        }\r\n\r\n        // find the token of the campaign\r\n        PMLibrary.PoolFullInfo memory poolFullInfo = IRewardCampaign(campaign)\r\n            .getProjectInfo();\r\n        address tokenAddress = poolFullInfo.projectInfo.tokenAddress;\r\n\r\n        // Buy tokens from open market\r\n        uint256 boughtTokens = swapETHForTokens(\r\n            tokenAddress,\r\n            address(this),\r\n            amount\r\n        );\r\n\r\n        // Approve tokens to the investment pool\r\n        IERC20(tokenAddress).approve(campaign, boughtTokens);\r\n\r\n        // Invest tokens on uers behalf\r\n        IRewardCampaign(campaign).investTokens(user, boughtTokens, _type);\r\n\r\n        emit RewardApplied(campaign, user, boughtTokens, uint8(_type));\r\n    }\r\n\r\n    /* Admin Functions */\r\n\r\n    function emergencyWithdraw() external onlyOwner {\r\n        uint256 totalBalance = address(this).balance;\r\n        require(totalBalance > 0, \"No balance avaialble for withdraw\");\r\n        payable(owner()).transfer(totalBalance);\r\n    }\r\n\r\n    function changePauseStatus(bool action) external onlyOwner {\r\n        s_isPaused = action;\r\n    }\r\n\r\n\r\n\r\n    function updateGiveAwayManager(\r\n        address _giveAwayManager\r\n    ) external onlyOwner {\r\n        s_giveAwayManager = _giveAwayManager;\r\n    }\r\n\r\n    function updateRouter(\r\n        IUniswapV2Router02 _uniswapV2Router\r\n    ) public onlyOwner {\r\n        uniswapV2Router = _uniswapV2Router;\r\n    }\r\n\r\n    function updatePriceFeed(\r\n        AggregatorV3Interface _priceFeed\r\n    ) public onlyOwner {\r\n        priceFeed = _priceFeed;\r\n    }\r\n\r\n    receive() external payable {\r\n        emit Received(msg.sender, msg.value);\r\n    }\r\n}\r\n"
    },
    "contracts/Planetmoon/PriceFeed.sol": {
      "content": "/**\r\n* Network: Goerli\r\n* Aggregator: ETH/USD\r\n* Address: 0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e\r\n*/\r\n\r\n\r\n/**\r\n* Network: BNB Chain Mainnet\r\n* Aggregator: BNB/USD\r\n* Address: 0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.18;\r\n\r\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\n\r\ncontract PriceFeed {\r\n\r\n    // AggregatorV3Interface internal priceFeed = AggregatorV3Interface(0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE); // BNB Chain Mainnet BNB/USD\r\n    AggregatorV3Interface internal priceFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306);  // Sepolia ETH/USD\r\n\r\n    function getLatestPriceOfOneUSD() public view returns (int price) {\r\n\r\n        // this is the price of 1 Eth in USDs  => 1 ETh = price USDs\r\n        // Find price of 1 USD => 1 USD = 1/price ETH\r\n\r\n        (, price,,,) = priceFeed.latestRoundData();\r\n        int ONE_ETH = 1 ether;\r\n        price = (ONE_ETH * 10**8)/price;\r\n\r\n        // price = int(756881949122395); \r\n\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/Planetmoon/SwapETHForTokens.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.18;\r\n\r\n// import {} \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport {IUniswapV2Router02} from \"../interfaces/IUniswapV2Router02.sol\";\r\n\r\ncontract SwapETHForTokens {\r\n\r\n    // IUniswapV2Router02 public uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E); //Pancakeswap router mainnet - BSC\r\n    // IUniswapV2Router02 public uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); //Uniswap router goerli testnet - ETH\r\n    IUniswapV2Router02 public uniswapV2Router = IUniswapV2Router02(0xB26B2De65D07eBB5E54C7F6282424D3be670E1f0); //Uniswap router sepolia testnet - ETH\r\n\r\n    function swapETHForTokens(\r\n        address tokenAddress,\r\n        address toAddress,\r\n        uint256 amount\r\n    ) internal returns (uint256) {\r\n        // generate the uniswap pair path of token -> weth\r\n        address[] memory path = new address[](2);\r\n        path[0] = uniswapV2Router.WETH();\r\n        path[1] = tokenAddress;\r\n\r\n        uint[] memory amounts = uniswapV2Router.swapExactETHForTokens{\r\n            value: amount\r\n        }(\r\n            0, // accept any amount of Tokens\r\n            path,\r\n            toAddress, // The contract\r\n            block.timestamp + 500\r\n        );\r\n        uint256 boughtTokens = amounts[amounts.length - 1];\r\n        return boughtTokens;\r\n    }\r\n\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}