{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IStakingPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\nimport \"../library/StakingLibrary.sol\";\r\n\r\ninterface IStakingPool is IERC721 {\r\n    \r\n    function stakeTokens(address onBehalf, uint256 amount, StakingLibrary.StakingType _type) external;\r\n    function unstakeTokens(uint256 _tokenId) external;  \r\n    function getTokenData(uint256 _tokenId) external view returns(StakingLibrary.TokenData memory);\r\n    function getProjectInfo() external view returns ( StakingLibrary.PoolFullInfo memory poolFullInfo);\r\n\r\n}"
    },
    "contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.14;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n"
    },
    "contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.14;\r\n\r\nimport './IUniswapV2Router01.sol';\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n"
    },
    "contracts/library/StakingLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.14;\r\n\r\nlibrary StakingLibrary {\r\n\r\n    enum UnstakingCategories {\r\n        REWARD_0pc,\r\n        REWARD_30pc,\r\n        REWARD_50pc,\r\n        REWARD_100pc\r\n    }\r\n\r\n    enum MembershipCategories {\r\n        REGULAR,\r\n        UPGRAGE,\r\n        PREMIUIM,\r\n        TEAM\r\n    }\r\n\r\n    enum CampaignCategories {\r\n        SILVER,\r\n        GOLD,\r\n        DIAMOND\r\n    }\r\n\r\n    struct PoolInfo {\r\n        uint256 poolId;\r\n        address poolAddress;\r\n        uint256 remainingPool;\r\n        uint256 totalTokensStaked;\r\n        uint256 totalParicipants;\r\n        uint256 tokenCounter;\r\n        address poolOwner;\r\n    }\r\n\r\n    enum ProfileType {NONE, TEAM, USER}\r\n    \r\n    enum StakingType { ONE_MONTH, THREE_MONTH, SIX_MONTH, NINE_MONTH, TWELVE_MONTH }\r\n\r\n    struct ProjectInfo {\r\n        CampaignCategories category;\r\n        string projectName;\r\n        string projectSymbol;\r\n        address tokenAddress;\r\n        uint8 tokenDecimals;\r\n        string tokenSymbol;\r\n        ProfileType profileType;\r\n        uint256 profileId;\r\n    }\r\n\r\n    struct RewardPoolInfo {\r\n        uint256 startedAt;\r\n        uint256 poolAmount;\r\n    }\r\n\r\n    struct NFTData {\r\n        string image_1_months;\r\n        string image_3_months;\r\n        string image_6_months;\r\n        string image_9_months;\r\n        string image_12_months;\r\n        uint8 APY_1_months;\r\n        uint8 APY_3_months;\r\n        uint8 APY_6_months;\r\n        uint8 APY_9_months;\r\n        uint8 APY_12_months;\r\n    }\r\n\r\n       \r\n    struct TokenData {\r\n        address poolAddress;\r\n        uint256 poolId;\r\n        uint256 tokenStaked;\r\n        address tokenAddress;\r\n        address owner;\r\n        address creator;\r\n        uint256 tokenId;\r\n        string tokenUri;\r\n        uint8 stakingType;\r\n        uint256 stakingTime;\r\n        uint256 unlockTime;\r\n        uint256 expectedReward;\r\n        bool isUnskated;\r\n        uint256 redeemedReward;\r\n        uint8 pcReceived;\r\n    }\r\n\r\n    struct PoolFullInfo {\r\n        PoolInfo poolInfo;\r\n        ProjectInfo projectInfo; \r\n        RewardPoolInfo rewardPoolInfo; \r\n        NFTData nftData;\r\n    }\r\n\r\n    struct UserDetail {\r\n        uint256 memberSince;\r\n        uint256 memberId;\r\n        bool isPremium;\r\n    }\r\n\r\n}\r\n\r\n\r\n"
    },
    "contracts/Planetmoon/CampaignFeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../library/StakingLibrary.sol\";\r\nimport \"../interfaces/IUniswapV2Router02.sol\";\r\nimport \"./PriceFeed.sol\";\r\nimport \"./SwapETHForTokens.sol\";\r\n\r\n// import \"hardhat/console.sol\";\r\n\r\ncontract CampaignFeeManager is Ownable, PriceFeed, SwapETHForTokens {\r\n\r\n    mapping (StakingLibrary.CampaignCategories => uint256) public campaingFee;\r\n    mapping (StakingLibrary.UnstakingCategories => uint256) public unStakingFee;\r\n    \r\n    event Received(address, uint);\r\n    enum FeesType {USD, BNB}\r\n    \r\n    FeeDistributionShares public feeDistributionShares;\r\n    struct FeeDistributionShares {\r\n        uint8 buyBackAndburn;\r\n        uint8 rewardPool;\r\n        uint8 corporate;\r\n    }\r\n\r\n    FeeDistributionWallets public feeDistributionWallets;\r\n    struct FeeDistributionWallets {\r\n        address payable rewardPool;\r\n        address payable corporate;\r\n        address buyBackAndburnToken;\r\n        address buyBackReceiver;\r\n    }\r\n\r\n    constructor( \r\n        uint256 silver, uint256 gold, uint256 diamond,\r\n        uint256 reward_0pc, uint256 reward_30pc, uint256 reward_50pc, uint256 reward_100pc\r\n    ) {\r\n\r\n        campaingFee[StakingLibrary.CampaignCategories.SILVER] = silver;\r\n        campaingFee[StakingLibrary.CampaignCategories.GOLD] = gold;\r\n        campaingFee[StakingLibrary.CampaignCategories.DIAMOND] = diamond;\r\n\r\n        unStakingFee[StakingLibrary.UnstakingCategories.REWARD_0pc] = reward_0pc;\r\n        unStakingFee[StakingLibrary.UnstakingCategories.REWARD_30pc] = reward_30pc;\r\n        unStakingFee[StakingLibrary.UnstakingCategories.REWARD_50pc] = reward_50pc;\r\n        unStakingFee[StakingLibrary.UnstakingCategories.REWARD_100pc] = reward_100pc;\r\n    }\r\n\r\n    function getCampaignFee(StakingLibrary.CampaignCategories category) public view returns (uint256){\r\n        uint256 priceOfOneUSD = uint256(getLatestPriceOfOneUSD());\r\n        return campaingFee[category] * priceOfOneUSD;\r\n    }\r\n\r\n    function getAllCampaignFees(FeesType feeType) public view returns (\r\n        uint256 silver,  \r\n        uint256 gold,  \r\n        uint256 diamond\r\n    ){\r\n\r\n        silver = campaingFee[StakingLibrary.CampaignCategories.SILVER];\r\n        gold = campaingFee[StakingLibrary.CampaignCategories.GOLD];\r\n        diamond = campaingFee[StakingLibrary.CampaignCategories.DIAMOND];\r\n\r\n        if(feeType == FeesType.BNB){\r\n            uint256 priceOfOneUSD = uint256(getLatestPriceOfOneUSD());\r\n            silver = silver * priceOfOneUSD;\r\n            gold = gold * priceOfOneUSD;\r\n            diamond = diamond * priceOfOneUSD;\r\n        }\r\n\r\n    }\r\n\r\n    function setCampaignFees(uint256 silver, uint256 gold, uint256 diamond) public onlyOwner {\r\n        campaingFee[StakingLibrary.CampaignCategories.SILVER] = silver;\r\n        campaingFee[StakingLibrary.CampaignCategories.GOLD] = gold;\r\n        campaingFee[StakingLibrary.CampaignCategories.DIAMOND] = diamond;\r\n    }\r\n\r\n    function getUnstakingFee(StakingLibrary.UnstakingCategories category) public view returns (uint256) {\r\n        uint256 priceOfOneUSD = uint256(getLatestPriceOfOneUSD());\r\n        return unStakingFee[category] * priceOfOneUSD;\r\n    }\r\n\r\n    function getAllUnstakingFees(FeesType feeType) public view returns (\r\n        uint256 reward_0pc, \r\n        uint256 reward_30pc, \r\n        uint256 reward_50pc, \r\n        uint256 reward_100pc\r\n    ){\r\n\r\n        reward_0pc = unStakingFee[StakingLibrary.UnstakingCategories.REWARD_0pc];\r\n        reward_30pc = unStakingFee[StakingLibrary.UnstakingCategories.REWARD_30pc];\r\n        reward_50pc = unStakingFee[StakingLibrary.UnstakingCategories.REWARD_50pc];\r\n        reward_100pc = unStakingFee[StakingLibrary.UnstakingCategories.REWARD_100pc];\r\n\r\n        if(feeType == FeesType.BNB){\r\n            uint256 priceOfOneUSD = uint256(getLatestPriceOfOneUSD());\r\n            reward_0pc = reward_0pc * priceOfOneUSD;\r\n            reward_30pc = reward_30pc * priceOfOneUSD;\r\n            reward_50pc = reward_50pc * priceOfOneUSD;\r\n            reward_100pc = reward_100pc * priceOfOneUSD;\r\n        }\r\n\r\n    }\r\n\r\n    function setUnstakingFees(\r\n        uint256 reward_0pc, \r\n        uint256 reward_30pc, \r\n        uint256 reward_50pc, \r\n        uint256 reward_100pc\r\n    ) public onlyOwner {\r\n        unStakingFee[StakingLibrary.UnstakingCategories.REWARD_0pc] = reward_0pc;\r\n        unStakingFee[StakingLibrary.UnstakingCategories.REWARD_30pc] = reward_30pc;\r\n        unStakingFee[StakingLibrary.UnstakingCategories.REWARD_50pc] = reward_50pc;\r\n        unStakingFee[StakingLibrary.UnstakingCategories.REWARD_100pc] = reward_100pc;\r\n    }\r\n\r\n    function setFeeDistributionShares(uint8 buyBackAndburn, uint8 rewardPool, uint8 corporate ) public onlyOwner {\r\n        require(\r\n            corporate > 0 && \r\n            rewardPool > 0 &&\r\n            buyBackAndburn + rewardPool + corporate == 100,\r\n            \"Distribution fees are not adding up to 100pc\" \r\n        );\r\n\r\n        feeDistributionShares.buyBackAndburn = buyBackAndburn;\r\n        feeDistributionShares.rewardPool = rewardPool;\r\n        feeDistributionShares.corporate = corporate;\r\n    }\r\n\r\n    function setFeeDistributionWallets(address rewardPool, address corporate, address buyBackAndburnToken, address buyBackReceiver) public onlyOwner {\r\n        \r\n        require(\r\n            rewardPool != address(0) && \r\n            corporate != address(0) &&\r\n            buyBackAndburnToken != address(0) && \r\n            buyBackReceiver != address(0),\r\n            \"Distribution wallets are not being set properly\" \r\n        );\r\n\r\n        feeDistributionWallets.rewardPool = payable(rewardPool);\r\n        feeDistributionWallets.corporate = payable(corporate);\r\n        feeDistributionWallets.buyBackAndburnToken = buyBackAndburnToken;\r\n        feeDistributionWallets.buyBackReceiver = buyBackReceiver;\r\n        \r\n    }\r\n\r\n    function SplitFunds() public onlyOwner {\r\n\r\n        FeeDistributionWallets memory wallets = feeDistributionWallets;\r\n        FeeDistributionShares memory fees = feeDistributionShares;\r\n\r\n        require(\r\n            wallets.rewardPool != address(0) && \r\n            wallets.corporate != address(0) &&\r\n            wallets.buyBackAndburnToken != address(0) && \r\n            wallets.buyBackReceiver != address(0),\r\n            \"Distribution wallets are not being set properly\" \r\n        );\r\n\r\n        require(\r\n            fees.corporate > 0 && \r\n            fees.rewardPool > 0 &&\r\n            fees.buyBackAndburn + fees.rewardPool + fees.corporate == 100,\r\n            \"Distribution fees are not being set properly\" \r\n        );\r\n\r\n        uint256 totalBalance = address(this).balance;\r\n        require(totalBalance > 0, \"No balance avaialble for split\");\r\n\r\n        uint256 corporateShare =  (totalBalance * fees.corporate) / 100;\r\n        uint256 rewardPoolShare =  (totalBalance * fees.rewardPool) / 100;\r\n        uint256 buyBackAndBurnShare =  totalBalance - corporateShare - rewardPoolShare;\r\n\r\n        wallets.corporate.transfer(corporateShare);\r\n        wallets.rewardPool.transfer(rewardPoolShare);\r\n        if(buyBackAndBurnShare > 0){\r\n            swapETHForTokens(wallets.buyBackAndburnToken, wallets.buyBackReceiver, buyBackAndBurnShare);\r\n        }\r\n        \r\n    }\r\n\r\n    function emergencyWithdraw() public onlyOwner {\r\n        uint256 totalBalance = address(this).balance;\r\n        require(totalBalance > 0, \"No balance avaialble for withdraw\");\r\n        payable(owner()).transfer(totalBalance);\r\n    }\r\n\r\n    receive() external payable {\r\n        emit Received(msg.sender, msg.value);\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/Planetmoon/MembershipFeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../library/StakingLibrary.sol\";\r\nimport \"../interfaces/IUniswapV2Router02.sol\";\r\nimport \"./PriceFeed.sol\";\r\nimport \"./SwapETHForTokens.sol\";\r\n\r\n// import \"hardhat/console.sol\";\r\n\r\ncontract MembershipFeeManager is Ownable, PriceFeed, SwapETHForTokens {\r\n\r\n    mapping (StakingLibrary.MembershipCategories => uint256) public membershipFee;\r\n    \r\n    enum FeesType {USD, BNB}\r\n\r\n    event Received(address, uint);\r\n    \r\n    FeeDistributionShares public feeDistributionShares;\r\n    struct FeeDistributionShares {\r\n        uint8 buyBackAndburn;\r\n        uint8 rewardPool;\r\n        uint8 corporate;\r\n    }\r\n\r\n    FeeDistributionWallets public feeDistributionWallets;\r\n    struct FeeDistributionWallets {\r\n        address payable rewardPool;\r\n        address payable corporate;\r\n        address buyBackAndburnToken;\r\n        address buyBackReceiver;\r\n    }\r\n\r\n    constructor( uint256 regular, uint256 upgrade, uint256 premium, uint256 team) {\r\n        membershipFee[StakingLibrary.MembershipCategories.REGULAR] = regular;\r\n        membershipFee[StakingLibrary.MembershipCategories.UPGRAGE] = upgrade;\r\n        membershipFee[StakingLibrary.MembershipCategories.PREMIUIM] = premium;\r\n        membershipFee[StakingLibrary.MembershipCategories.TEAM] = team;\r\n    }\r\n\r\n    function getMembershipFee(StakingLibrary.MembershipCategories category) public view returns (uint256){\r\n        uint256 priceOfOneUSD = uint256(getLatestPriceOfOneUSD());\r\n        return membershipFee[category] * priceOfOneUSD;\r\n    }\r\n\r\n    function getAllFees(FeesType feeType) public view returns (\r\n        uint256 regular,\r\n        uint256 upgrade,\r\n        uint256 premium,\r\n        uint256 team\r\n    ){\r\n            regular = membershipFee[StakingLibrary.MembershipCategories.REGULAR];\r\n            upgrade = membershipFee[StakingLibrary.MembershipCategories.UPGRAGE];\r\n            premium = membershipFee[StakingLibrary.MembershipCategories.PREMIUIM];\r\n            team = membershipFee[StakingLibrary.MembershipCategories.TEAM];\r\n\r\n            if(feeType == FeesType.BNB){\r\n                uint256 priceOfOneUSD = uint256(getLatestPriceOfOneUSD());\r\n                regular = regular * priceOfOneUSD;\r\n                upgrade = upgrade * priceOfOneUSD;\r\n                premium = premium * priceOfOneUSD;\r\n                team = team * priceOfOneUSD;\r\n            }\r\n\r\n    }\r\n\r\n    function setMembershipFee(uint256 regular, uint256 upgrade, uint256 premium, uint256 team) public onlyOwner {\r\n        membershipFee[StakingLibrary.MembershipCategories.REGULAR] = regular;\r\n        membershipFee[StakingLibrary.MembershipCategories.UPGRAGE] = upgrade;\r\n        membershipFee[StakingLibrary.MembershipCategories.PREMIUIM] = premium;\r\n        membershipFee[StakingLibrary.MembershipCategories.TEAM] = team;\r\n    }\r\n\r\n    function setFeeDistributionShares(uint8 buyBackAndburn, uint8 rewardPool, uint8 corporate ) public onlyOwner {\r\n        require(\r\n            corporate > 0 && \r\n            rewardPool > 0 &&\r\n            buyBackAndburn + rewardPool + corporate == 100,\r\n            \"Distribution fees are not adding up to 100pc\" \r\n        );\r\n\r\n        feeDistributionShares.buyBackAndburn = buyBackAndburn;\r\n        feeDistributionShares.rewardPool = rewardPool;\r\n        feeDistributionShares.corporate = corporate;\r\n    }\r\n\r\n    function setFeeDistributionWallets(\r\n        address rewardPool, \r\n        address corporate, \r\n        address buyBackAndburnToken, \r\n        address buyBackReceiver\r\n        ) public onlyOwner {\r\n        require(\r\n            rewardPool != address(0) && \r\n            corporate != address(0) &&\r\n            buyBackAndburnToken != address(0) && \r\n            buyBackReceiver != address(0),\r\n            \"Distribution wallets are not being set properly\" \r\n        );\r\n\r\n        feeDistributionWallets.rewardPool = payable(rewardPool);\r\n        feeDistributionWallets.corporate = payable(corporate);\r\n        feeDistributionWallets.buyBackAndburnToken = buyBackAndburnToken;\r\n        feeDistributionWallets.buyBackReceiver = buyBackReceiver;\r\n        \r\n    }\r\n\r\n    function SplitFunds() public onlyOwner {\r\n\r\n        FeeDistributionWallets memory wallets = feeDistributionWallets;\r\n        FeeDistributionShares memory fees = feeDistributionShares;\r\n\r\n        require(\r\n            wallets.rewardPool != address(0) && \r\n            wallets.corporate != address(0) &&\r\n            wallets.buyBackAndburnToken != address(0) && \r\n            wallets.buyBackReceiver != address(0),\r\n            \"Distribution wallets are not being set properly\" \r\n        );\r\n\r\n        require(\r\n            fees.corporate > 0 && \r\n            fees.rewardPool > 0 &&\r\n            fees.buyBackAndburn + fees.rewardPool + fees.corporate == 100,\r\n            \"Distribution fees are not being set properly\" \r\n        );\r\n\r\n        uint256 totalBalance = address(this).balance;\r\n        require(totalBalance > 0, \"No balance avaialble for split\");\r\n\r\n        uint256 corporateShare =  (totalBalance * fees.corporate) / 100;\r\n        uint256 rewardPoolShare =  (totalBalance * fees.rewardPool) / 100;\r\n        uint256 buyBackAndBurnShare =  totalBalance - corporateShare - rewardPoolShare;\r\n\r\n        wallets.corporate.transfer(corporateShare);\r\n        wallets.rewardPool.transfer(rewardPoolShare);\r\n        if(buyBackAndBurnShare > 0){\r\n            swapETHForTokens(wallets.buyBackAndburnToken, wallets.buyBackReceiver, buyBackAndBurnShare);\r\n        }\r\n        \r\n    }\r\n\r\n    function emergencyWithdraw() public onlyOwner {\r\n        uint256 totalBalance = address(this).balance;\r\n        require(totalBalance > 0, \"No balance avaialble for withdraw\");\r\n        payable(owner()).transfer(totalBalance);\r\n    }\r\n\r\n    receive() external payable {\r\n        emit Received(msg.sender, msg.value);\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/Planetmoon/PMRewardDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../library/StakingLibrary.sol\";\r\nimport \"../interfaces/IUniswapV2Router02.sol\";\r\nimport \"../interfaces/IStakingPool.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./PriceFeed.sol\";\r\nimport \"./SwapETHForTokens.sol\";\r\n\r\n// import \"hardhat/console.sol\";\r\n\r\nerror NOT_ENOUGH_BALANCE();\r\nerror CONTRACT_IS_PAUSED();\r\n\r\ncontract PMRewardDistributor is Ownable, PriceFeed, SwapETHForTokens {\r\n\r\n    event Received(address, uint);\r\n    event RewardApplied(address, address, uint256, uint8);\r\n\r\n    address public giveAwayManager;\r\n    bool public pause = true;\r\n    uint256 public totalRewardDistributed;\r\n\r\n    constructor( address _giveAwayManager ){\r\n        giveAwayManager = _giveAwayManager;\r\n    }\r\n\r\n    modifier onlyGiveAwayManager(){\r\n        require(msg.sender == giveAwayManager, \"No Authorized\");\r\n        _;\r\n    }\r\n\r\n    function distributeReward(address winner, uint8 prizeUSD) public onlyGiveAwayManager {\r\n\r\n        if(pause){\r\n            revert CONTRACT_IS_PAUSED();\r\n        }\r\n\r\n\r\n        uint256 priceOfOneUSD = uint256(getLatestPriceOfOneUSD());\r\n\r\n        uint256 prizeBNB = priceOfOneUSD * prizeUSD;\r\n        totalRewardDistributed = totalRewardDistributed + prizeBNB;\r\n\r\n        uint256 totalBalance = address(this).balance;\r\n\r\n        if(totalBalance <  prizeBNB){\r\n            revert NOT_ENOUGH_BALANCE();\r\n        }\r\n        payable(winner).transfer(prizeBNB);\r\n\r\n    }\r\n\r\n    function applyRewardToACampaing(address campaign, address user, uint8 amountUSD, StakingLibrary.StakingType _type) public onlyGiveAwayManager {\r\n\r\n        if(pause){\r\n            revert CONTRACT_IS_PAUSED();\r\n        }\r\n\r\n        uint256 priceOfOneUSD = uint256(getLatestPriceOfOneUSD());\r\n\r\n        uint256 amount = priceOfOneUSD * amountUSD;\r\n        totalRewardDistributed = totalRewardDistributed + amount;\r\n\r\n        uint256 totalBalance = address(this).balance;\r\n\r\n        if(totalBalance <  amount){\r\n            revert NOT_ENOUGH_BALANCE();\r\n        }\r\n\r\n        // find the token of the campaign\r\n        StakingLibrary.PoolFullInfo memory poolFullInfo = IStakingPool(campaign).getProjectInfo();\r\n        address tokenAddress = poolFullInfo.projectInfo.tokenAddress;\r\n\r\n        // Buy tokens from open market\r\n        uint256 boughtTokens = swapETHForTokens(tokenAddress, address(this), amount);\r\n\r\n        // Approve tokens to the staking pool\r\n        IERC20(tokenAddress).approve(campaign, boughtTokens);\r\n\r\n        // Stake tokens on uers behalf\r\n        IStakingPool(campaign).stakeTokens(user, boughtTokens, _type);\r\n\r\n        emit RewardApplied(campaign, user, boughtTokens, uint8(_type));\r\n\r\n    }\r\n\r\n    /* Admin Functions */\r\n\r\n    function emergencyWithdraw() public onlyOwner{\r\n        uint256 totalBalance = address(this).balance;\r\n        require(totalBalance > 0, \"No balance avaialble for withdraw\");\r\n        payable(owner()).transfer(totalBalance);\r\n    }\r\n\r\n    function changePauseStatus(bool action) public onlyOwner {\r\n        pause = action;\r\n    }\r\n\r\n    function updateGiveAwayManager(address _giveAwayManager) public onlyOwner {\r\n        giveAwayManager = _giveAwayManager;\r\n    }\r\n\r\n    receive() external payable {\r\n        emit Received(msg.sender, msg.value);\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/Planetmoon/PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\n\r\n/**\r\n* Network: Goerli\r\n* Aggregator: ETH/USD\r\n* Address: 0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e\r\n*/\r\n\r\n\r\n/**\r\n* Network: BNB Chain Mainnet\r\n* Aggregator: BNB/USD\r\n* Address: 0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE\r\n*/\r\n\r\ncontract PriceFeed {\r\n\r\n    AggregatorV3Interface internal priceFeed = AggregatorV3Interface(0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE); // BNB Chain Mainnet BNB/USD\r\n    // AggregatorV3Interface internal priceFeed = AggregatorV3Interface(0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e);  // Goerli ETH/USD\r\n\r\n    function getLatestPriceOfOneUSD() public view returns (int price) {\r\n\r\n        // this is the price of 1 Eth in USDs  => 1 ETh = price USDs\r\n        // Find price of 1 USD => 1 USD = 1/price ETH\r\n\r\n        (, price,,,) = priceFeed.latestRoundData();\r\n        int ONE_ETH = 1 ether;\r\n        price = (ONE_ETH * 10**8)/price;\r\n\r\n        // price = int(756881949122395); \r\n\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/Planetmoon/SwapETHForTokens.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.14;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../interfaces/IUniswapV2Router02.sol\";\r\n\r\ncontract SwapETHForTokens is Ownable {\r\n\r\n    IUniswapV2Router02 public uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E); //Pancakeswap router mainnet - BSC\r\n    // IUniswapV2Router02 public uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); //Uniswap router goerli testnet - ETH\r\n\r\n    function setRouter(IUniswapV2Router02 _uniswapV2Router) public onlyOwner {\r\n        uniswapV2Router = _uniswapV2Router;\r\n    }\r\n\r\n    function swapETHForTokens(\r\n        address tokenAddress,\r\n        address toAddress,\r\n        uint256 amount\r\n    ) internal returns (uint256) {\r\n        // generate the uniswap pair path of token -> weth\r\n        address[] memory path = new address[](2);\r\n        path[0] = uniswapV2Router.WETH();\r\n        path[1] = tokenAddress;\r\n\r\n        uint[] memory amounts = uniswapV2Router.swapExactETHForTokens{\r\n            value: amount\r\n        }(\r\n            0, // accept any amount of Tokens\r\n            path,\r\n            toAddress, // The contract\r\n            block.timestamp + 500\r\n        );\r\n        uint256 boughtTokens = amounts[amounts.length - 1];\r\n        return boughtTokens;\r\n    }\r\n\r\n\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}